# -*- coding: utf-8 -*-
# Generated by Django 1.11.13 on 2018-09-26 20:08
from __future__ import unicode_literals

from django.db import migrations

FORMAT_TYPE_TO_TYPE_MAP = {
    ('multiselect', 'choose'): 'multiselect',
    (None, 'multiselect'): 'multiselect',
    (None, 'choose'): 'singleselect',
    ('osf-upload-open', 'osf-upload'): 'osf-upload',
    ('osf-upload-toggle', 'osf-upload'): 'osf-upload',
    ('singleselect', 'choose'): 'singleselect',
    ('text', 'string'): 'string',
    ('textarea', 'osf-author-import'): 'osf-author-import',
    ('textarea', 'string'): 'string',
    ('textarea-lg', None): 'string',
    ('textarea-lg', 'string'): 'string',
    ('textarea-xl', 'string'): 'string',
}

FORMAT_TO_SIZE_MAP = {
    'text': 'sm',
    'textarea': 'md',
    'textarea-lg': 'lg',
    'textarea-xl': 'xl',
}

DEFAULT_SIZE = 'md'

def remove_version_1_schemas(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    assert RegistrationSchema.objects.filter(schema_version=1, abstractnode__isnull=False).count() == 0
    assert RegistrationSchema.objects.filter(schema_version=1, draftregistration__isnull=False).count() == 0
    RegistrationSchema.objects.filter(schema_version=1).delete()

def update_schemaless_registrations(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    AbstractNode = state.get_model('osf', 'abstractnode')

    open_ended_schema = RegistrationSchema.objects.get(name='Open-Ended Registration')
    open_ended_meta = {
        '{}'.format(open_ended_schema._id): {
            'summary': {
                'comments': [],
                'extra': [],
                'value': ''
            }
        }
    }

    schemaless_regs_with_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True).exclude(registered_meta={})
    schemaless_regs_without_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True, registered_meta={})

    for reg in schemaless_regs_without_meta.all():
        reg.registered_schema.add(open_ended_schema)
        reg.registered_meta = open_ended_meta
        reg.save()

    for reg in schemaless_regs_with_meta.all():
        reg.registered_schema.add(RegistrationSchema.objects.get(_id=reg.registered_meta.keys()[0]))

def update_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    for rs in RegistrationSchema.objects.filter(schema_version=2):
        rs.config = rs.schema.get('config', {})
        # assert not rs.config.get('tooltip', False)
        if rs.schema.get('description', False):
            rs.config['tooltip'] = rs.schema['description']
        rs.save()

def unset_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    RegistrationSchema.objects.update(config=dict())

def _build_block(state, obj, **blargs):
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')
    EXPECTED_BLARGS = set([
        'page',
        'section',
        'schema_id',
        'block_id',
        'block_text',
        'block_type',
        '_order',
    ])
    assert EXPECTED_BLARGS.issubset(set(blargs.keys()))
    blargs['help_text'] = obj.get('help', '')
    blargs['choices'] = obj.get('options', [])
    blargs['required'] = False if blargs['block_type'] == 'header' else obj.get('required', True)
    blargs['size'] = FORMAT_TO_SIZE_MAP.get(obj.get('format', None), DEFAULT_SIZE)
    return RegistrationFormBlock(**blargs)

def _generate_ridie_formblocks(state, question, page, _order, schema_id):
    """ Builds formblocks from question information. RIDIE schemas are flat, with the
        exception of file-upload questions, which appear to be nested based on "type",
        but actually should not be.

    :param StateApps state: Current Django model state
    :param dict question: Question to build from
    :param dict page: Page for context
    :param int _order: Order for the next form block
    :ret tuple(list, int): Returns a tuple of (<List of built blocks>, <_order for next block>)
    """
    blocks = []
    blargs = {
        'page': page['title'],
        'section': question['title'],
        'schema_id': schema_id,
        'block_id': question['qid'],
        'block_text': question['description'],
        'block_type': 'osf-upload' if question['type'] == 'object' else FORMAT_TYPE_TO_TYPE_MAP[(question['format'], question['type'])],
        '_order': _order,
    }
    block = _build_block(state, question, **blargs)
    blocks.append(block)
    _order += 1
    return blocks, _order

def _generate_formblocks(state, question, page, _order, schema_id):
    """ Builds formblocks from question information.

    :param StateApps state: Current Django model state
    :param dict question: Question to build from
    :param dict page: Page for context
    :param int _order: Order for the next form block
    :ret tuple(list, int): Returns a tuple of (<List of built blocks>, <_order for next block>)
    """
    blocks = []
    _type = question['type']
    qid = question['qid']
    blargs = {
        'page': page['title'],
        'section': question['title'],
        'schema_id': schema_id,
        '_order': _order,
    }

    if _type == 'object':
        if question.get('description', False):
            # Question header create
            blargs.update({
                'block_id': qid,
                'block_type': 'header',
                'block_text': question['description'],
            })
            block = _build_block(state, question, **blargs)
            blocks.append(block)
            blargs['_order'] = _order = _order + 1
        for obj in question['properties']:
            _qid = obj['id']
            if obj['type'] == 'object':
                if obj.get('description', False):
                    # Question sub-header create
                    blargs.update({
                        'block_id': '.'.join([qid, _qid]),
                        'block_type': 'header',
                        'block_text': obj['description'],
                    })
                    block = _build_block(state, obj, **blargs)
                    blocks.append(block)
                    blargs['_order'] = _order = _order + 1
                for _obj in obj['properties']:
                    # sub-sub block create
                    __qid = _obj['id']
                    blargs.update({
                        'block_id': '.'.join([qid, _qid, __qid]),
                        'block_type': FORMAT_TYPE_TO_TYPE_MAP[(_obj['format'], _obj.get('type', None))],
                        'block_text': _obj['description'],
                    })
                    block = _build_block(state, _obj, **blargs)
                    blocks.append(block)
                    blargs['_order'] = _order = _order + 1
            else:
                # sub block create
                blargs.update({
                    'block_id': '.'.join([qid, _qid]),
                    'block_type': FORMAT_TYPE_TO_TYPE_MAP[(obj['format'], obj.get('type', None))],
                    'block_text': obj.get('description', None) or obj.get('title', None) or '',
                })
                block = _build_block(state, obj, **blargs)
                blocks.append(block)
                blargs['_order'] = _order = _order + 1
    else:
        # block create
        blargs.update({
            'block_id': qid,
            'block_type': FORMAT_TYPE_TO_TYPE_MAP[(question.get('format', None), question.get('type', None))],
            'block_text': question['title'],
        })
        block = _build_block(state, question, **blargs)
        blocks.append(block)
        blargs['_order'] = _order = _order + 1
    return blocks, _order


def map_schema_to_formblocks(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')
    blocks_to_create = []
    for rs in RegistrationSchema.objects.filter(schema_version=2):
        _order = 1
        for page in rs.schema['pages']:
            if page.get('description', False):
                block = RegistrationFormBlock(
                    page=page['title'],
                    block_id=page['id'],
                    section=None,
                    block_type='header',
                    block_text=page['description'],
                    required=False,
                    schema_id=rs.id,
                    _order=_order,
                )
                blocks_to_create.append(block)
                _order += 1
            for question in page['questions']:
                if 'RIDIE' in rs.name:
                    blocks, _order = _generate_ridie_formblocks(state, question, page, _order, rs.id)
                else:
                    blocks, _order = _generate_formblocks(state, question, page, _order, rs.id)
                for block in blocks:
                    blocks_to_create.append(block)

    RegistrationFormBlock.objects.bulk_create(blocks_to_create)

def unmap_formblocks(state, schema):
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')
    RegistrationFormBlock.objects.all().delete()

def noop(*args, **kwargs):
    pass

def create_block(state, schema_id, block_type, block_text='', required=False, help_text='',
        question_id=''):
    RegistrationFormBlock = state.get_model('osf', 'registrationformblock')

    return RegistrationFormBlock.objects.create(
        schema_id=schema_id,
        block_type=block_type,
        required=required,
        block_text=block_text,
        help_text=help_text,
        question_id=question_id,
    )

# WIP exploring making schemas more flat -
def map_osf_standard_pre_data_collection_registration(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    schema = RegistrationSchema.objects.get(name='OSF-Standard Pre-Data Collection Registration', schema_version=2)

    for page in schema.schema['pages']:
        create_block(
            state,
            schema.id,
            'h1',
            block_text=page['title'],
        )
        for question in page['questions']:
            create_block(
                state,
                schema.id,
                'input-label',
                block_text=question['title']
            )
            if question['format'] == 'singleselect':
                create_block(
                    state,
                    schema.id,
                    'singleselect',
                    required=True,
                    question_id=question['qid']
                )
                for option in question['options']:
                    create_block(
                        state,
                        schema.id,
                        'select-input-option',
                        block_text=option
                    )
            elif question['format'] == 'textarea':
                create_block(
                    state,
                    schema.id,
                    'long-text-input',
                )


class Migration(migrations.Migration):

    dependencies = [
        ('osf', '0175_alter_form_blocks_v2'),
    ]

    operations = [
        migrations.RunPython(remove_version_1_schemas, noop),
        migrations.RunPython(update_schemaless_registrations, noop),
        migrations.RunPython(update_schema_configs, unset_schema_configs),
        # migrations.RunPython(map_schema_to_formblocks, unmap_formblocks),
        migrations.RunPython(map_osf_standard_pre_data_collection_registration, unmap_formblocks)
    ]
