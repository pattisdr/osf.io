# -*- coding: utf-8 -*-
# Generated by Django 1.11.13 on 2018-08-27 21:07
from __future__ import unicode_literals

import logging
from django.db import migrations, connection
from osf.utils.migrations import batch_node_migrations

logger = logging.getLogger(__name__)

"""
NODE MIGRATION
1) Creates three django groups for each existing abstract node (admin/write/read)
2) Gives admin groups admin/write/read perms, write groups write/read, and read: read
 - Populates osf NodeGroupObjectPermission (DFK) table instead of out-of-the-box guardian GroupObjectPermission table
3) Adds node contributors to corresponding django groups - a node write contributor is added to the node's write django group
 - Populates OSFUserGroups table with group id/user id pair
"""

increment = 100000

# Reverse migration - contributor read/write/admin columns preserved during forward migration.
# If reversing data that's been sitting for awhile, the old contributor columns could differ
# from what's being repopulated
reset_contributor_perms = """
    -- Resetting contributor table permissions to all false, so updates afterwards
    -- only flip fields that should be TRUE
    UPDATE osf_contributor
    SET admin = FALSE, write = FALSE, read = FALSE
    WHERE node_id > {start} AND node_id <= {end};
    """

# Reverse migration - Repopulate contributor table with read permissions
repopulate_read_perms = """
    -- Repopulate contributor table with read perms
    UPDATE osf_contributor C
    SET read = TRUE
    FROM osf_osfuser_groups UG, osf_nodegroupobjectpermission NG, auth_permission AS PERM
    WHERE UG.group_id = NG.group_id
    AND C.node_id = NG.content_object_id
    AND PERM.codename='read_node'
    AND NG.permission_id = PERM.id
    AND C.user_id = UG.osfuser_id
    AND NG.content_object_id > {start} AND NG.content_object_id <= {end};
    """

# Reverse migration - Repopulate contributor table with write permissions
repopulate_write_perms = """
    -- Repopulate contributor table with write perms
    UPDATE osf_contributor C
    SET write = TRUE
    FROM osf_osfuser_groups UG, osf_nodegroupobjectpermission NG, auth_permission AS PERM
    WHERE UG.group_id = NG.group_id
    AND C.node_id = NG.content_object_id
    AND PERM.codename='write_node'
    AND NG.permission_id = PERM.id
    AND C.user_id = UG.osfuser_id
    AND NG.content_object_id > {start} AND NG.content_object_id <= {end};
    """

# Reverse migration - Repopulate contributor table with admin permissions
repopulate_admin_perms = """
    -- Repopulate contributor table with admin perms
    UPDATE osf_contributor C
    SET admin = TRUE
    FROM osf_osfuser_groups UG, osf_nodegroupobjectpermission NG, auth_permission AS PERM
    WHERE UG.group_id = NG.group_id
    AND C.node_id = NG.content_object_id
    AND PERM.codename='admin_node'
    AND NG.permission_id = PERM.id
    AND C.user_id = UG.osfuser_id
    AND NG.content_object_id > {start} AND NG.content_object_id <= {end};
    """

# Reverse migration - Remove all rows from NodeGroupObjectPermission table - table gives node django groups
# permissions to node
drop_node_group_object_permission_table = """
    DELETE FROM osf_nodegroupobjectpermission;
    """

# Reverse migration - Remove user membership in Node read/write/admin Django groups
remove_users_from_node_django_groups = """
    DELETE FROM osf_osfuser_groups
      WHERE group_id IN (
        SELECT id FROM auth_group WHERE name LIKE '%node_%'
      );
    """

# Reverse migration - creates new auth_group table, we're going to swap the new with the old
# Removing the majority of the rows in the auth_group table is a very time-consuming operation
# due to the large number of foreign keys pointing to this, so we're doing this for speed.  We
# are just going to create a new auth_group table with only the rows that we want to keep.
create_temporary_auth_group_table = """
    CREATE TABLE auth_group_copy (LIKE auth_group INCLUDING ALL);
    INSERT INTO auth_group_copy
    SELECT * FROM auth_group
    WHERE name NOT LIKE '%node_%';
    """

# Reverse migration create group id column
create_group_id_column = """
    ALTER TABLE {table}
    ADD column group_id_copy INTEGER;
    """

# Reverse migration create group id column
create_group_id_column_with_constraint = """
    ALTER TABLE {table}
    ADD column group_id_copy INTEGER
    REFERENCES auth_group_copy(id);
    """

# Reverse migration - repoints tables with FK's to auth_group to the new auth_group table
repoint_auth_group_foreign_keys = """
    UPDATE {table}
    SET group_id_copy = group_id;

    ALTER TABLE {table} DROP COLUMN group_id;

    ALTER TABLE {table} RENAME group_id_copy TO group_id;
"""

# Reverse migration -
set_not_null_constraint = """
    ALTER TABLE {table} ALTER COLUMN group_id SET NOT NULL;
"""

# Reverse migration -
create_index_on_group_id = """
    CREATE INDEX {table}_group_id ON {table} (group_id);
"""

select_auth_group_permissions_auth_group_constraint = """
    SELECT conname
    FROM pg_constraint
    WHERE conrelid = 'auth_group_permissions'::regclass::oid
    AND confrelid = 'auth_group'::regclass::oid;
"""

# Reverse migration - _
set_deferred_initially_deferred = """
    ALTER TABLE auth_group_permissions
    ALTER CONSTRAINT {}
    DEFERRABLE INITIALLY DEFERRED;
"""

# List of tables that have foreign keys to auth_group
related_auth_group_tables = [
    'auth_group_permissions',
    'osf_osfuser_groups',
    'guardian_groupobjectpermission',
    'waffle_flag_groups',
    'osf_collectiongroupobjectpermission',
    'osf_abstractprovidergroupobjectpermission',
    'osf_nodegroupobjectpermission',
    'osf_preprintgroupobjectpermission',
]

group_id_constraints = [
    'auth_group_permissions',
    'osf_osfuser_groups',
    'osf_collectiongroupobjectpermission',
    'osf_nodegroupobjectpermission',
    'osf_preprintgroupobjectpermission',
]

# Reverse migration - replaces old auth_group table with new auth_group table
swap_old_auth_group_table_with_new_auth_group_table = """
    ALTER TABLE auth_group RENAME TO auth_group_deleted;
    ALTER TABLE auth_group_copy RENAME TO auth_group;
    ALTER SEQUENCE auth_group_id_seq OWNED BY NONE;
    DROP TABLE auth_group_deleted;
    ALTER SEQUENCE auth_group_id_seq OWNED BY auth_group.id;

    ALTER TABLE auth_group_permissions ADD CONSTRAINT auth_group_permissions_group_id_permission_id UNIQUE ("group_id", "permission_id");
    ALTER TABLE osf_nodegroupobjectpermission ADD CONSTRAINT unique_node_group_object_permission UNIQUE ("group_id", "permission_id", "content_object_id");
    ALTER TABLE osf_preprintgroupobjectpermission ADD CONSTRAINT unique_preprint_group_object_permission UNIQUE ("group_id", "permission_id", "content_object_id");
"""

def get_constraint_name():
    with connection.cursor() as cursor:
        cursor.execute(select_auth_group_permissions_auth_group_constraint)
        constraint_name = cursor.fetchone()[0]
        return constraint_name

# Reverse migration
def finalize_reverse_node_guardian_migration():
    """
    After restoring contributor permissions, this runs to finalize removing rows to tables
    that were added for guardian.

    Creates new auth_group table that only contains groups not added with node guardian work
    """

    with connection.cursor() as cursor:
        cursor.execute(drop_node_group_object_permission_table)
        logger.info('Finished deleting records from NodeGroupObjectPermission table.')
        cursor.execute(remove_users_from_node_django_groups)
        logger.info('Finished removing users from guardian node django groups.')
        cursor.execute(create_temporary_auth_group_table)
        logger.info('Created new auth_group_table.')

        # Treating some of the tables that point to auth_group differently
        for table_name in related_auth_group_tables:
            if table_name in group_id_constraints:
                cursor.execute(create_group_id_column_with_constraint.format(table=table_name))
            else:
                cursor.execute(create_group_id_column.format(table=table_name))

            cursor.execute(repoint_auth_group_foreign_keys.format(table=table_name))

            if table_name == 'auth_group_permissions':
                cursor.execute(set_not_null_constraint.format(table=table_name))
                cursor.execute(create_index_on_group_id.format(table=table_name))

        logger.info('Repointed foreign keys to new auth_group_table.')

        cursor.execute(swap_old_auth_group_table_with_new_auth_group_table)
        logger.info('Swapped old auth_group table with new auth_group table.')

    # Altering foreign key constraint on auth_group_permission table to match existing configuration
    constraint_name = get_constraint_name()
    with connection.cursor() as cursor:
        cursor.execute(set_deferred_initially_deferred.format(constraint_name))


def reverse_guardian_migration(state, schema):
    migrations = [
        {'sql': reset_contributor_perms, 'description': 'Resetting contributor permissions.'},
        {'sql': repopulate_read_perms, 'description': 'Repopulating read columns on Contributor table'},
        {'sql': repopulate_write_perms, 'description': 'Repopulating write columns on Contributor table.'},
        {'sql': repopulate_admin_perms, 'description': 'Repopulating admin columns on Contributor table.'},
    ]

    batch_node_migrations(state, migrations)
    logger.info('Finished restoring Contributor permissions.')
    finalize_reverse_node_guardian_migration()
    return

# Forward migration - for each node, create a read, write, and admin Django group
add_node_read_write_admin_auth_groups = """
    INSERT INTO auth_group (name)
    SELECT regexp_split_to_table('node_' || N.id || '_read,node_' || N.id || '_write,node_' || N.id || '_admin', ',')
    FROM osf_abstractnode N
    WHERE N.id > {start} AND N.id <= {end};
    """

# Forward migration - add read permissions to all node django read groups, add read/write perms
# to all node django write groups, and add read/write/admin perms to all node django admin groups
add_permissions_to_node_groups = """
    -- Adds "read_node" permissions to all Node read groups - uses NodeGroupObjectPermission table
    INSERT INTO osf_nodegroupobjectpermission (content_object_id, group_id, permission_id)
    SELECT N.id as content_object_id, G.id as group_id, PERM.id AS permission_id
    FROM osf_abstractnode AS N, auth_group G, auth_permission AS PERM
    WHERE G.name = 'node_' || N.id || '_read'
    AND PERM.codename = 'read_node'
    AND N.id > {start}
    AND N.id <= {end};

    -- Adds "read_node" and "write_node" permissions to all Node write groups
    INSERT INTO osf_nodegroupobjectpermission (content_object_id, group_id, permission_id)
    SELECT N.id as object_pk, G.id as group_id, PERM.id AS permission_id
    FROM osf_abstractnode AS N, auth_group G, auth_permission AS PERM
    WHERE G.name = 'node_' || N.id || '_write'
    AND (PERM.codename = 'read_node' OR PERM.codename = 'write_node')
    AND N.id > {start}
    AND N.id <= {end};

    -- Adds "read_node", "write_node", and "admin_node" permissions to all Node admin groups
    INSERT INTO osf_nodegroupobjectpermission (content_object_id, group_id, permission_id)
    SELECT N.id as object_pk, G.id as group_id, PERM.id AS permission_id
    FROM osf_abstractnode AS N, auth_group G, auth_permission AS PERM
    WHERE G.name = 'node_' || N.id || '_admin'
    AND (PERM.codename = 'read_node' OR PERM.codename = 'write_node' OR PERM.codename = 'admin_node')
    AND N.id > {start}
    AND N.id <= {end};
    """

# Forward migration - for every contributor that has read perms only to a node,
# add that contributor to the node's read group - this allows us to start using
# guardian to track which permissions a contributor has.
add_read_contribs_to_read_groups = """
    -- Add users with read permissions only on the node to the node's read group
    INSERT INTO osf_osfuser_groups (osfuser_id, group_id)
    SELECT C.user_id as osfuser_id, G.id as group_id
    FROM osf_abstractnode as N, osf_contributor as C, auth_group as G
    WHERE C.node_id = N.id
    AND C.read = TRUE
    AND C.write = FALSE
    AND C.admin = FALSE
    AND G.name = 'node_' || N.id || '_read'
    AND N.id > {start}
    AND N.id <= {end};
    """

# Forward migration - for every contributor that has write and read perms to a node,
# add that contributor to the node's write group - this allows us to start using
# guardian to track which permissions a contributor has.
add_write_contribs_to_write_groups = """
    -- Add users with write permissions on node to the node's write group
    INSERT INTO osf_osfuser_groups (osfuser_id, group_id)
    SELECT C.user_id as osfuser_id, G.id as group_id
    FROM osf_abstractnode as N, osf_contributor as C, auth_group as G
    WHERE C.node_id = N.id
    AND C.read = TRUE
    AND C.write = TRUE
    AND C.admin = FALSE
    AND G.name = 'node_' || N.id || '_write'
    AND N.id > {start}
    AND N.id <= {end};
    """

# Forward migration - for every contributor that has admin/write/read perms to a node,
# add that contributor to the node's admin group - this allows us to start using
# guardian to track which permissions a contributor has.
add_admin_contribs_to_admin_groups = """
    -- Add users with admin permissions on the node to the node's admin group
    INSERT INTO osf_osfuser_groups (osfuser_id, group_id)
    SELECT C.user_id as osfuser_id, G.id as group_id
    FROM osf_abstractnode as N, osf_contributor as C, auth_group as G
    WHERE C.node_id = N.id
    AND C.read = TRUE
    AND C.write = TRUE
    AND C.admin = TRUE
    AND G.name = 'node_' || N.id || '_admin'
    AND N.id > {start}
    AND N.id <= {end};
    """

def migrate_nodes_to_guardian(state, schema):
    migrations = [
        {'sql': add_node_read_write_admin_auth_groups, 'description': 'Creating node admin/write/read django groups:'},
        {'sql': add_permissions_to_node_groups, 'description': 'Adding permissions to node django groups:'},
        {'sql': add_read_contribs_to_read_groups, 'description': 'Adding node read contribs to read django groups:'},
        {'sql': add_write_contribs_to_write_groups, 'description': 'Adding node write contribs to write django groups:'},
        {'sql': add_admin_contribs_to_admin_groups, 'description': 'Adding node admin contribs to admin django groups:'}
    ]

    batch_node_migrations(state, migrations)
    logger.info('Finished adding guardian to nodes.')
    return


class Migration(migrations.Migration):

    dependencies = [
        ('osf', '0163_migrate_preprints_to_direct_fks'),
    ]

    operations = [
        migrations.RunPython(migrate_nodes_to_guardian, reverse_guardian_migration),
    ]
